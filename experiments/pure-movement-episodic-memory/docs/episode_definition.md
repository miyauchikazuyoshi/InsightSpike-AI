# エピソード定義詳細仕様書

## 1. エピソードベクトル構造

### 1.1 基本構造（7次元）

```python
episode_vector = [
    x,          # 次元0: x座標（正規化）
    y,          # 次元1: y座標（正規化）  
    direction,  # 次元2: 移動方向（正規化）
    success,    # 次元3: 成功フラグ
    wall_path,  # 次元4: 壁/通路識別子
    visit_cnt,  # 次元5: 訪問回数（対数正規化）
    goal        # 次元6: ゴールフラグ
]
```

### 1.2 各次元の詳細定義

#### 次元0-1: 位置座標
- **記録内容**: 移動を試みた開始位置
- **正規化**: `x / maze_height`, `y / maze_width`
- **値域**: [0.0, 1.0]
- **注意**: 移動後の位置ではなく、移動前の位置を記録

#### 次元2: 移動方向
- **エンコーディング**:
  - 上（up）: 0.00
  - 右（right）: 0.33
  - 下（down）: 0.67
  - 左（left）: 1.00
- **値域**: {0.00, 0.33, 0.67, 1.00}
- **クエリ時**: 0.5（中立値）で「どの方向でも良い」を表現

#### 次元3: 成功フラグ
- **成功** (移動できた): 1.0
- **失敗** (壁/境界): 0.0
- **未実行** (視覚エピソード): 0.5

#### 次元4: 壁/通路識別
- **通路**: 1.0
- **壁**: -1.0
- **不明/中立**: 0.0

#### 次元5: 訪問回数
- **計算式**: `log(1 + visit_count) / 10.0`
- **理由**: 対数スケールで大きな訪問回数の影響を抑制
- **値域**: [0.0, ~1.0]（実質的に）

#### 次元6: ゴールフラグ
- **ゴール到達**: 1.0
- **通常位置**: 0.0
- **クエリ時**: 0.5（中立）または1.0（ゴール志向）

## 2. エピソードの種類と生成タイミング

### 2.1 移動エピソード（Movement Episode）

**生成タイミング**: 移動を試みた後

```python
def create_movement_episode(start_x, start_y, action, success, is_wall):
    return [
        start_x / height,           # 移動開始位置x
        start_y / width,            # 移動開始位置y
        action_to_float(action),    # 試みた方向
        1.0 if success else 0.0,   # 成功/失敗
        -1.0 if is_wall else 1.0,  # 壁/通路
        log1p(visits) / 10.0,      # 訪問回数
        1.0 if reached_goal else 0.0  # ゴール
    ]
```

### 2.2 視覚エピソード（Visual Episode）

**生成タイミング**: 各ステップの開始時（移動前）

```python
def create_visual_episode(x, y, direction):
    # 指定方向を観測
    next_x, next_y = get_next_position(x, y, direction)
    is_wall = check_wall(next_x, next_y)
    
    return [
        x / height,                 # 観測位置x
        y / width,                  # 観測位置y
        direction_to_float(direction),  # 観測方向
        0.5,                        # 未実行を示す中立値
        -1.0 if is_wall else 1.0,  # 観測結果
        log1p(visits) / 10.0,      # 現在位置の訪問回数
        0.0                         # ゴールフラグ（通常0）
    ]
```

## 3. クエリベクトル仕様

### 3.1 標準クエリ（現在位置から成功移動を検索）

```python
query = [
    current_x / height,     # 現在位置x
    current_y / width,      # 現在位置y
    0.5,                   # 方向は問わない（中立）
    1.0,                   # 成功した移動を求める
    0.0,                   # 壁/通路は中立
    log1p(current_visits) / 10.0,  # 現在の訪問状況
    0.5                    # ゴールは中立
]
```

### 3.2 禁止されるクエリパターン

以下のようなチート的クエリは**禁止**：

```python
# ❌ ゴールバイアスクエリ（禁止）
bad_query = [
    current_x / height,
    current_y / width,
    preferred_direction,   # ゴール方向を優遇
    1.0,
    0.0,
    -visit_penalty,       # 訪問回数にペナルティ
    1.0                   # ゴールを強く求める
]
```

## 4. エピソード間の関係性

### 4.1 GeDIG値による結合

エピソード間のエッジには以下の情報を付与：
- **weight**: コサイン類似度
- **gedig**: 情報理論的な差異
- **quality**: weight × (1 - gedig × 0.3)

### 4.2 視覚エピソードと移動エピソードの連携

```
視覚エピソード（観測） → 移動エピソード（実行）
    ↓                      ↓
次の視覚エピソード  →  次の移動エピソード
```

## 5. メタデータ構造

各エピソードには以下のメタデータを付与：

```python
metadata = {
    'type': 'movement' or 'visual',
    'position': (x, y),
    'action': 'up'/'right'/'down'/'left',
    'success': True/False,
    'timestamp': episode_id,
    'c_value': 0.0-1.0,  # 信頼度
}
```

## 6. 正規化の理由

### 位置の正規化
- 異なるサイズの迷路で共通の表現
- コサイン類似度計算の安定性

### 訪問回数の対数正規化
- 線形だと大きな値が支配的になる
- 対数により適度な影響に抑制
- 10で除算して[0,1]範囲に収める

### 方向の離散値
- 4方向のみなので離散値で十分
- 0.33刻みで均等配置
- 中間値（0.5）で中立を表現

## 7. 実装上の注意点

1. **エピソード追加順序**:
   - 視覚エピソード（4方向）→ 行動決定 → 移動エピソード

2. **メモリ管理**:
   - エピソード数が増えすぎないよう古いものを削除可能
   - ただし、成功エピソードは優先的に保持

3. **同期の保証**:
   - ベクトルとメタデータの一貫性を常に保つ
   - インデックス更新時は両方を更新

4. **デバッグ用途**:
   - 各エピソードにテキスト説明を付与
   - 可視化のためのposition情報を保持