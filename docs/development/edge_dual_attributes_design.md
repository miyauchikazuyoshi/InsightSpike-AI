---
status: active
category: edges
owner: refactor-wg
created: 2025-08-25
last_review: 2025-08-25
---

# エッジ2属性化（距離・角度）設計ドキュメント

## 概要
現在のInsightSpike-AIのグラフ構造では、エッジは単一の類似度スコアのみを持つ。これを距離と角度の2属性に拡張することで、より豊かな知識表現と矛盾検出を実現する。

## 現状の問題点

### 1. 単純な類似度では捉えきれない関係性
- 「温度を上げる」と「温度を下げる」は高い類似度（同じトピック）
- しかし方向性は正反対（矛盾）
- 現在は文字列マッチングでしか矛盾を検出できない

### 2. 矛盾の本質を数値化できていない
- ベクトル空間での「反対方向」を表現できない
- 類似しているが矛盾する概念の検出が不十分

## 再考：角度と距離は冗長？

実は、コサイン類似度から導出される角度と距離は**同じ情報の異なる表現**：
- コサイン類似度 = cos(θ)
- 距離 = 1 - cos(θ)
- 角度 = θ = arccos(cos(θ))

つまり、どちらか一方があれば他方は計算可能。

## 一般的な類似度指標の整理

### 標準的な選択順位
1. **コサイン類似度** - テキスト埋め込みのデファクトスタンダード
   - 正規化済みベクトルでは内積と等価
   - 方向のみに注目、大きさを無視
   
2. **内積（Dot Product）** - 実はよく使われる
   - FAISSのIndexFlatIPなど
   - 大きさも考慮した類似度
   
3. **ユークリッド距離** - 画像処理などで人気
   - L2距離とも呼ばれる
   - 絶対的な位置の近さ
   
4. **マンハッタン距離（L1）** - スパースデータ向け
5. **ジャカード係数** - 集合の類似度

### NLPにおける実情
- **Sentence-BERT**: コサイン類似度を推奨
- **OpenAI Embeddings**: コサイン類似度を推奨
- **FAISS**: 内積（IP）とL2距離の両方をサポート

### 問題：コサイン類似度だけでは不十分
- 「温度を1度上げる」と「温度を100度上げる」が同じ扱い
- スケールの違いを無視してしまう

### 正規化とユークリッド距離の関係

**重要な数学的関係**：
```
正規化ベクトル間のユークリッド距離 = √(2 - 2×cos(θ))
```

つまり：
- cos(θ) = 1 (同一) → 距離 = 0
- cos(θ) = 0 (直交) → 距離 = √2 ≈ 1.414
- cos(θ) = -1 (正反対) → 距離 = 2

**結論**: 正規化後のユークリッド距離はコサイン類似度の単調変換！
→ 新しい情報を提供しない

### 新しい候補

#### 候補A: ノルム（大きさ）の比
```python
magnitude_ratio = ||vec1|| / ||vec2||
# または
magnitude_diff = abs(||vec1|| - ||vec2||)
```
- **利点**: 方向とは独立した「強度」の違い
- **例**: 「少し増やす」vs「大幅に増やす」

#### 候補B: 共通成分の割合
```python
# 内積をノルムで正規化しない版
raw_dot_product = np.dot(vec1, vec2)
shared_magnitude = raw_dot_product / (||vec1|| * ||vec2||)
```
- **利点**: どれだけ同じ成分を共有しているか

#### 候補C: 最大成分の差
```python
# 各次元での最大差分
max_component_diff = max(abs(vec1[i] - vec2[i]) for i in range(dim))
```
- **利点**: 最も異なる側面を捉える

#### 候補D: 符号の一致率
```python
sign_agreement = sum(sign(v1) == sign(v2) for v1, v2 in zip(vec1, vec2)) / dim
```
- **利点**: 方向性の部分的一致を評価

### ノード属性 vs エッジ属性の整理
**ノード属性（エピソード自体の性質）**:
- 確信度（C値）
- タイムスタンプ
- 重要度

**エッジ属性（関係性の性質）**:
- コサイン類似度（方向の一致度）
- ユークリッド距離（ベクトル空間での距離）

## 実装設計

### 1. データ構造の変更

```python
# PyTorch Geometricのグラフ構造
class Data:
    x: torch.Tensor          # ノード特徴量
    edge_index: torch.Tensor # エッジの接続情報
    edge_attr: torch.Tensor  # [NEW] エッジ属性 [distance, angle]
```

### 2. エッジ作成時の計算

```python
def calculate_edge_attributes(vec1: np.ndarray, vec2: np.ndarray) -> Tuple[float, float]:
    """2つのベクトルからエッジ属性を計算"""
    # 正規化
    norm1 = np.linalg.norm(vec1)
    norm2 = np.linalg.norm(vec2)
    
    # コサイン類似度
    cos_sim = np.dot(vec1, vec2) / (norm1 * norm2)
    cos_sim = np.clip(cos_sim, -1.0, 1.0)  # 数値誤差対策
    
    # 距離（0-2の範囲）
    distance = 1.0 - cos_sim
    
    # 角度（0-πの範囲）
    angle = np.arccos(cos_sim)
    
    return distance, angle
```

### 3. 絶対値処理の候補

#### a) 角度の離散化
```python
# 角度を離散的なカテゴリに分類
def categorize_angle(angle: float) -> str:
    if angle < π/6:      # 0-30°
        return "aligned"
    elif angle < π/3:    # 30-60°
        return "related"
    elif angle < 2*π/3:  # 60-120°
        return "orthogonal"
    else:                # 120-180°
        return "opposed"
```

#### b) 矛盾フラグ
```python
# 閾値を超えたら矛盾とみなす（二値化）
def is_contradictory(distance: float, angle: float) -> bool:
    return distance < 0.3 and angle > 2*π/3  # 近いけど120°以上
```

#### c) 統合スコア
```python
# 距離と角度を1つのスコアに統合
def combined_score(distance: float, angle: float) -> float:
    # 距離が近く、角度が大きいほど高スコア（矛盾度）
    return (1.0 - distance) * (angle / π)
```

## 影響を受けるコンポーネント

### 1. ScalableGraphManager
- エッジ作成ロジックの変更
- 矛盾検出の高度化

### 2. GED計算（GraphEditDistance）
- エッジ置換コストの再定義
- 属性変化を考慮したGED

### 3. Layer3（GraphReasoner）
- GNNでのエッジ属性の活用
- メッセージパッシングの重み付け

### 4. GraphMemorySearch
- パス探索時の角度制約
- 累積角度によるパスの評価

### 5. 可視化ツール
- エッジの表示方法（太さ=距離、色=角度）

## 実装の段階的アプローチ

### Phase 1: 基本実装
1. edge_attrの追加
2. 距離・角度の計算
3. 既存コードとの互換性維持

### Phase 2: 矛盾検出の改善
1. 角度ベースの矛盾検出
2. 分裂判定の高度化

### Phase 3: GED/IG計算の拡張
1. エッジ属性を考慮したGED
2. 質的変化の検出

### Phase 4: 高度な活用
1. GNNでの活用
2. パス探索の最適化

## 議論ポイント

### 1. 絶対値化すべき箇所
- [ ] 矛盾フラグ（二値化）
- [ ] 角度カテゴリ（4段階程度）
- [ ] 統合スコア（単一値化）

### 2. 閾値の設定
- 矛盾と判定する角度は？（120°？150°？）
- 「近い」と判定する距離は？（0.3？0.2？）

### 3. 後方互換性
- 既存のデータをどう扱うか
- 段階的移行の方法

### 4. パフォーマンス
- 計算コストの増加は許容範囲か
- キャッシュ戦略

## 現在の課題（議論のキッカケ）

### 1. 矛盾検出の限界
- 現在：単純な文字列マッチング（increase/decrease等）
- 問題：数学的・論理的矛盾を検出できない
- 例：「負の数は存在しない」と「0-1=-1」の矛盾を検出できない

### 2. エッジ評価のタイミング
- **エピソード追加時**：FAISSでtop-k検索 → コサイン類似度計算
- **エッジ作成判定**：similarity_threshold超えたらエッジ作成
- **矛盾チェック**：conflict_threshold超えたら矛盾検出
- しかし矛盾検出後の処理が不明確

### 3. 洞察エピソードの管理
**InsightFactRegistry**は存在するが：
- 洞察は検出・登録される
- でも対応するエピソードベクトルが生成されない？
- L2MemoryManagerとの連携が不明

## 期待される効果

1. **より正確な矛盾検出**
   - 表面的な類似性と本質的な矛盾を区別
   - 上位概念獲得の精度向上

2. **洞察の質の向上**
   - エッジの質的変化を検出
   - 矛盾解消プロセスの可視化

3. **知識グラフの表現力向上**
   - 関係性の多面的表現
   - より人間的な知識構造